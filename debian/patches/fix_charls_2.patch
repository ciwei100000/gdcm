Description: Fix compiling with CharLS 2.0
Author: Gert Wollny <gewo@debian.org>

diff -ur gdcm/CMakeLists.txt gdcm-2.8.8/CMakeLists.txt
--- gdcm/CMakeLists.txt	2019-01-13 08:57:04.807970487 +0100
+++ gdcm-2.8.8/CMakeLists.txt	2019-01-13 08:51:36.459974494 +0100
@@ -368,7 +368,7 @@
 
 if(GDCM_USE_SYSTEM_CHARLS)
   find_package(CharLS REQUIRED)
-  set(GDCM_CHARLS_LIBRARIES ${CHARLS_LIBRARIES})
+  set(GDCM_CHARLS_LIBRARIES ${CHARLS_LIBRARY})
 else()
   set(GDCM_CHARLS_LIBRARIES gdcmcharls)
 endif()
diff -ur gdcm/Source/MediaStorageAndFileFormat/gdcmJPEGLSCodec.cxx gdcm-2.8.8/Source/MediaStorageAndFileFormat/gdcmJPEGLSCodec.cxx
--- gdcm/Source/MediaStorageAndFileFormat/gdcmJPEGLSCodec.cxx	2018-10-28 18:03:34.314814207 +0100
+++ gdcm-2.8.8/Source/MediaStorageAndFileFormat/gdcmJPEGLSCodec.cxx	2019-01-13 08:47:03.239977827 +0100
@@ -22,6 +22,12 @@
 // CharLS includes
 #include "gdcm_charls.h"
 
+#include <cstring>
+
+using BYTE=unsigned char;
+#define ILV_LINE charls::InterleaveMode::Line;
+#define ILV_NONE charls::InterleaveMode::None;
+
 #if defined(__GNUC__) && GCC_VERSION < 50101
 #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
 #endif
@@ -61,7 +67,7 @@
 
   JlsParameters metadata = {};
   //assert(buf_size < INT_MAX);
-  if (JpegLsReadHeader(dummy_buffer, (unsigned int)buf_size, &metadata) != OK)
+  if (JpegLsReadHeader(dummy_buffer, (unsigned int)buf_size, &metadata, NULL) != charls::ApiResult::OK)
     {
     return false;
     }
@@ -71,22 +77,22 @@
 
   this->Dimensions[0] = metadata.width;
   this->Dimensions[1] = metadata.height;
-  if( metadata.bitspersample <= 8 )
+  if( metadata.bitsPerSample <= 8 )
     {
     this->PF = PixelFormat( PixelFormat::UINT8 );
     }
-  else if( metadata.bitspersample <= 16 )
+  else if( metadata.bitsPerSample <= 16 )
     {
-    assert( metadata.bitspersample > 8 );
+    assert( metadata.bitsPerSample > 8 );
     this->PF = PixelFormat( PixelFormat::UINT16 );
     }
   else
     {
     assert(0);
     }
-  this->PF.SetBitsStored( (uint16_t)metadata.bitspersample );
+  this->PF.SetBitsStored( (uint16_t)metadata.bitsPerSample );
   assert( this->PF.IsValid() );
-//  switch( metadata.bitspersample )
+//  switch( metadata.bitsPerSample )
 //    {
 //  case 8:
 //    this->PF = PixelFormat( PixelFormat::UINT8 );
@@ -115,9 +121,9 @@
   else assert(0);
 
   // allowedlossyerror == 0 => Lossless
-  LossyFlag = metadata.allowedlossyerror != 0;
+  LossyFlag = metadata.allowedLossyError != 0;
 
-  if( metadata.allowedlossyerror == 0 )
+  if( metadata.allowedLossyError == 0 )
     {
     ts = TransferSyntax::JPEGLSLossless;
     }
@@ -156,20 +162,20 @@
   size_t cbyteCompressed = totalLen;
 
   JlsParameters params = {};
-  if(JpegLsReadHeader(pbyteCompressed, cbyteCompressed, &params) != OK )
+  if(JpegLsReadHeader(pbyteCompressed, cbyteCompressed, &params, NULL) != charls::ApiResult::OK )
     {
     gdcmDebugMacro( "Could not parse JPEG-LS header" );
     return false;
     }
 
-  // allowedlossyerror == 0 => Lossless
-  LossyFlag = params.allowedlossyerror!= 0;
+  // allowedLossyError == 0 => Lossless
+  LossyFlag = params.allowedLossyError!= 0;
 
-  rgbyteOut.resize(params.height *params.width * ((params.bitspersample + 7) / 8) * params.components);
+  rgbyteOut.resize(params.height *params.width * ((params.bitsPerSample + 7) / 8) * params.components);
 
-  JLS_ERROR result = JpegLsDecode(&rgbyteOut[0], rgbyteOut.size(), pbyteCompressed, cbyteCompressed, &params);
+  auto result = JpegLsDecode(&rgbyteOut[0], rgbyteOut.size(), pbyteCompressed, cbyteCompressed, &params, NULL);
 
-  if (result != OK)
+  if (result != charls::ApiResult::OK)
     {
     gdcmErrorMacro( "Could not decode JPEG-LS stream" );
     return false;
@@ -229,23 +235,23 @@
       size_t cbyteCompressed = totalLen;
 
       JlsParameters params = {};
-      if( JpegLsReadHeader(pbyteCompressed, cbyteCompressed, &params) != OK )
+      if( JpegLsReadHeader(pbyteCompressed, cbyteCompressed, &params, NULL) != charls::ApiResult::OK )
         {
         gdcmDebugMacro( "Could not parse JPEG-LS header" );
         return false;
         }
 
-      // allowedlossyerror == 0 => Lossless
-      LossyFlag = params.allowedlossyerror!= 0;
+      // allowedLossyError == 0 => Lossless
+      LossyFlag = params.allowedLossyError!= 0;
 
       std::vector<BYTE> rgbyteOut;
-      rgbyteOut.resize(params.height *params.width * ((params.bitspersample + 7) / 8) * params.components);
+      rgbyteOut.resize(params.height *params.width * ((params.bitsPerSample + 7) / 8) * params.components);
 
-      JLS_ERROR result = JpegLsDecode(&rgbyteOut[0], rgbyteOut.size(), pbyteCompressed, cbyteCompressed, &params);
+      auto result = JpegLsDecode(&rgbyteOut[0], rgbyteOut.size(), pbyteCompressed, cbyteCompressed, &params, NULL);
       bool r = true;
 
       delete[] mybuffer;
-      if (result != OK)
+      if (result != charls::ApiResult::OK)
         {
         return false;
         }
@@ -285,7 +291,7 @@
   provide the possiblity to tune the JPEG-LS internals for better compression
   ratios. Expect a lot of work and testing to achieve small improvements.
 
-  Lossy/lossless is controlled by the field allowedlossyerror. If you put in
+  Lossy/lossless is controlled by the field allowedLossyError. If you put in
   0, encoding is lossless. If it is non-zero, then encoding is lossy. The
   value of 3 is often suggested as a default.
 
@@ -305,7 +311,7 @@
   that for 12 bit, the encoder fails if the unused bits are non-zero, but the
   sample dit not suffer from that.
    */
-  params.allowedlossyerror = !LossyFlag ? 0 : LossyError;
+  params.allowedLossyError = !LossyFlag ? 0 : LossyError;
   params.components = sample_pixel;
   // D_CLUNIE_RG3_JPLY.dcm. The famous 16bits allocated / 10 bits stored with the pixel value = 1024
   // CharLS properly encode 1024 considering it as 10bits data, so the output
@@ -316,28 +322,28 @@
   if( true || pf.GetPixelRepresentation() )
     {
     // gdcmData/CT_16b_signed-UsedBits13.dcm
-    params.bitspersample = bitsallocated;
+    params.bitsPerSample = bitsallocated;
     }
   else
     {
-    params.bitspersample = bitsstored;
+    params.bitsPerSample = bitsstored;
     }
   params.height = image_height;
   params.width = image_width;
 
   if (sample_pixel == 4)
     {
-    params.ilv = ILV_LINE;
+    params.interleaveMode = ILV_LINE;
     }
   else if (sample_pixel == 3)
     {
-    params.ilv = ILV_LINE;
-    params.colorTransform = COLORXFORM_HP1;
+    params.interleaveMode = ILV_LINE;
+    params.colorTransformation = charls::ColorTransformation::HP1;
     }
 
 
-  JLS_ERROR error = JpegLsEncode(outdata, outlen, &complen, indata, inlen, &params);
-  if( error != OK )
+  auto error = JpegLsEncode(outdata, outlen, &complen, indata, inlen, &params, NULL);
+  if( error != charls::ApiResult::OK )
     {
     gdcmErrorMacro( "Error compressing: " << (int)error );
     return false;
diff -ur gdcm/Utilities/gdcm_charls.h gdcm-2.8.8/Utilities/gdcm_charls.h
--- gdcm/Utilities/gdcm_charls.h	2018-04-10 09:03:57.874058559 +0200
+++ gdcm-2.8.8/Utilities/gdcm_charls.h	2019-01-13 08:30:27.575989976 +0100
@@ -18,13 +18,7 @@
 #include "gdcmTypes.h"
 #ifdef GDCM_USE_SYSTEM_CHARLS
 // It is expected that version 1.1.0 is used
-# include <CharLS/header.h>
-# include <CharLS/interface.h>
-# include <CharLS/util.h>
-# include <CharLS/defaulttraits.h>
-# include <CharLS/losslesstraits.h>
-# include <CharLS/colortransform.h>
-# include <CharLS/processline.h>
+# include <CharLS/charls.h>
 #else
 #include "gdcmcharls/header.h"
 #include "gdcmcharls/interface.h"
